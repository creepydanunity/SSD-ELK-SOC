input {
  http_poller {
    urls => {
      otx_pulses => {
        method           => "get"
        url              => "https://otx.alienvault.com/api/v1/pulses/subscribed"
        headers => {
          "X-OTX-API-KEY" => "07af3a46cbd66475aaecba02aa3b1218a7e36ba414edc60cc60d1a1389c2ae24"
        }
      }
    }
    codec           => "json"
    request_timeout => 60
    schedule        => { cron => "0 * * * *" }
  }
}

filter {
  if [results] {
    ruby {
      init   => "require 'net/http'; require 'uri'; require 'json'"
      code   => "
        # accumulate indicators by type
        @ipv4   ||= []
        @file   ||= []
        @domain ||= []
        @email  ||= []

        process = ->(page) do
          page['results'].each do |pulse|
            pulse['indicators'].each do |i|
              rec = { 'indicator' => i['indicator'], 'type' => i['type'], 'pulse_name' => pulse['name'], 'pulse_id' => pulse['id'] }
              case i['type']
              when 'IPv4' then @ipv4   << rec
              when 'FileHash-MD5','FileHash-SHA1','FileHash-SHA256' then @file   << rec
              when 'domain','URL','hostname' then @domain << rec
              when 'email' then @email  << rec
              end
            end
          end
        end

        # page 1
        process.call(event.to_hash)

        # follow pagination
        nxt = event.get('next')
        while nxt && !nxt.empty?
          uri = URI(nxt)
          req = Net::HTTP::Get.new(uri)
          req['X-OTX-API-KEY'] = '07af3a46cbd66475aaecba02aa3b1218a7e36ba414edc60cc60d1a1389c2ae24'
          res = Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme=='https'){|h| h.request(req)}
          break unless res.code.to_i == 200
          page = JSON.parse(res.body)
          process.call(page)
          nxt = page['next']
        end

        # emit *each* indicator as its own event
        @ipv4.each   {|i| event.set('[cache][ipv4]',   i); event.tag('cache_hit'); event.to_hash; yield; }
        @file.each   {|i| event.set('[cache][file]',   i); event.tag('cache_hit'); event.to_hash; yield; }
        @domain.each {|i| event.set('[cache][domain]', i); event.tag('cache_hit'); event.to_hash; yield; }
        @email.each  {|i| event.set('[cache][email]',  i); event.tag('cache_hit'); event.to_hash; yield; }

        # stop original HTTPâ€poller event
        event.cancel
      "
    }

    mutate {
      remove_field => [ "headers", "request", "response", "results", "next", "response_headers" ]
    }
  }
}

output {
  pipeline {
    send_to => ["backend_logs"]
  }

  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "threat-intel-otx-%{+YYYY.MM.dd}"
  }
}